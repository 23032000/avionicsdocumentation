(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{104:function(n,e,t){"use strict";t.r(e),t.d(e,"frontMatter",(function(){return l})),t.d(e,"metadata",(function(){return o})),t.d(e,"toc",(function(){return s})),t.d(e,"default",(function(){return c}));var i=t(3),r=t(7),a=(t(0),t(109)),l={id:"testes",title:"C\xf3digos de Teste",sidebar_label:"Testes"},o={unversionedId:"aurorav2/software/testes",id:"aurorav2/software/testes",isDocsHomePage:!1,title:"C\xf3digos de Teste",description:"I2C Scanner",source:"@site/docs/aurorav2/software/testes.md",slug:"/aurorav2/software/testes",permalink:"/avionicsdocumentation/docs/aurorav2/software/testes",editUrl:"https://github.com/gabrielaleks/avionicsdocumentation/edit/master/my-website/docs/aurorav2/software/testes.md",version:"current",sidebar_label:"Testes",sidebar:"docs",previous:{title:"SPI",permalink:"/avionicsdocumentation/docs/aurorav2/software/protocolos/spi"},next:{title:"Design Rule Check (DRC)",permalink:"/avionicsdocumentation/docs/aurorav2/hardware/altium/drc"}},s=[{value:"I2C Scanner",id:"i2c-scanner",children:[]},{value:"INA219",id:"ina219",children:[]},{value:"BMP280",id:"bmp280",children:[]},{value:"MPU9250",id:"mpu9250",children:[]},{value:"BMP388",id:"bmp388",children:[]},{value:"LoRa RFM95W",id:"lora-rfm95w",children:[]},{value:"MicroSD Adapter",id:"microsd-adapter",children:[]},{value:"MTK3339",id:"mtk3339",children:[]}],d={toc:s};function c(n){var e=n.components,t=Object(r.a)(n,["components"]);return Object(a.b)("wrapper",Object(i.a)({},d,t,{components:e,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"i2c-scanner"},"I2C Scanner"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),'#include <Arduino.h>\n#include <Wire.h>\n \nvoid setup()\n{\n  Wire.begin();\n \n  Serial.begin(9600);\n  while (!Serial);             // Leonardo: wait for serial monitor\n  Serial.println("\\nI2C Scanner");\n}\n \n \nvoid loop()\n{\n  byte error, address;\n  int nDevices;\n \n  Serial.println("Scanning...");\n \n  nDevices = 0;\n  for(address = 1; address < 127; address++ )\n  {\n    // The i2c_scanner uses the return value of\n    // the Write.endTransmisstion to see if\n    // a device did acknowledge to the address.\n    Wire.beginTransmission(address);\n    error = Wire.endTransmission();\n \n    if (error == 0)\n    {\n      Serial.print("I2C device found at address 0x");\n      if (address<16)\n        Serial.print("0");\n      Serial.print(address,HEX);\n      Serial.println("  !");\n \n      nDevices++;\n    }\n    else if (error==4)\n    {\n      Serial.print("Unknown error at address 0x");\n      if (address<16)\n        Serial.print("0");\n      Serial.println(address,HEX);\n    }    \n  }\n  if (nDevices == 0)\n    Serial.println("No I2C devices found\\n");\n  else\n    Serial.println("done\\n");\n \n  delay(5000);           // wait 5 seconds for next scan\n}\n')),Object(a.b)("h2",{id:"ina219"},"INA219"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),'#include <Arduino.h>\n#include <Adafruit_Sensor.h>\n#include <Wire.h>\n#include <Adafruit_INA219.h>\n\nAdafruit_INA219 ina219;\n\nvoid setup(void) \n{\n  Serial.begin(115200);\n  while (!Serial) {\n      // will pause Zero, Leonardo, etc until serial console opens\n      delay(1);\n  }\n\n  uint32_t currentFrequency;\n    \n  Serial.println("Hello!");\n  \n  // Initialize the INA219.\n  // By default the initialization will use the largest range (32V, 2A).  However\n  // you can call a setCalibration function to change this range (see comments).\n  if (! ina219.begin()) {\n    Serial.println("Failed to find INA219 chip");\n    while (1) { delay(10); }\n  }\n  // To use a slightly lower 32V, 1A range (higher precision on amps):\n  //ina219.setCalibration_32V_1A();\n  // Or to use a lower 16V, 400mA range (higher precision on volts and amps):\n  //ina219.setCalibration_16V_400mA();\n\n  Serial.println("Measuring voltage and current with INA219 ...");\n}\n\nvoid loop(void) \n{\n  float shuntvoltage = 0;\n  float busvoltage = 0;\n  float current_mA = 0;\n  float loadvoltage = 0;\n  float power_mW = 0;\n\n  shuntvoltage = ina219.getShuntVoltage_mV();\n  busvoltage = ina219.getBusVoltage_V();\n  current_mA = ina219.getCurrent_mA();\n  power_mW = ina219.getPower_mW();\n  loadvoltage = busvoltage + (shuntvoltage / 1000);\n  \n  Serial.print("Bus Voltage:   "); Serial.print(busvoltage); Serial.println(" V");\n  Serial.print("Shunt Voltage: "); Serial.print(shuntvoltage); Serial.println(" mV");\n  Serial.print("Load Voltage:  "); Serial.print(loadvoltage); Serial.println(" V");\n  Serial.print("Current:       "); Serial.print(current_mA); Serial.println(" mA");\n  Serial.print("Power:         "); Serial.print(power_mW); Serial.println(" mW");\n  Serial.println("");\n\n  delay(2000);\n}\n')),Object(a.b)("h2",{id:"bmp280"},"BMP280"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),'\n#include <Arduino.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <Adafruit_BMP280.h>\n\nAdafruit_BMP280 bmp; // I2C\n//Adafruit_BMP280 bmp(BMP_CS); // hardware SPI\n//Adafruit_BMP280 bmp(BMP_CS, BMP_MOSI, BMP_MISO,  BMP_SCK);\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(F("BMP280 test"));\n\n  if (!bmp.begin()) {\n    Serial.println(F("Could not find a valid BMP280 sensor, check wiring!"));\n    while (1);\n  }\n\n  /* Default settings from datasheet. */\n  bmp.setSampling(Adafruit_BMP280::MODE_NORMAL,     /* Operating Mode. */\n                  Adafruit_BMP280::SAMPLING_X2,     /* Temp. oversampling */\n                  Adafruit_BMP280::SAMPLING_X16,    /* Pressure oversampling */\n                  Adafruit_BMP280::FILTER_X16,      /* Filtering. */\n                  Adafruit_BMP280::STANDBY_MS_500); /* Standby time. */\n}\n\nvoid loop() {\n    Serial.print(F("Temperature = "));\n    Serial.print(bmp.readTemperature());\n    Serial.println(" *C");\n\n    Serial.print(F("Pressure = "));\n    Serial.print(bmp.readPressure());\n    Serial.println(" Pa");\n\n    Serial.print(F("Approx altitude = "));\n    Serial.print(bmp.readAltitude(1012)); /* Adjusted to local forecast! */\n    Serial.println(" m");\n\n    Serial.println();\n    delay(2000);\n}\n')),Object(a.b)("h2",{id:"mpu9250"},"MPU9250"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),'#include <Arduino.h>\n#include "MPU9250.h"\n\n// an MPU9250 object with the MPU-9250 sensor on I2C bus 0 with address 0x68\nMPU9250 IMU(Wire,0x68);\nint status;\n\nvoid setup() {\n  // serial to display data\n  Serial.begin(115200);\n  while(!Serial) {}\n\n  // start communication with IMU \n  status = IMU.begin();\n  if (status < 0) {\n    Serial.println("IMU initialization unsuccessful");\n    Serial.println("Check IMU wiring or try cycling power");\n    Serial.print("Status: ");\n    Serial.println(status);\n    while(1) {}\n  }\n\n}\n\nvoid loop() {\n  // read the sensor\n  IMU.readSensor();\n  // display the data\n  Serial.print(IMU.getAccelX_mss(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getAccelY_mss(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getAccelZ_mss(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getGyroX_rads(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getGyroY_rads(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getGyroZ_rads(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getMagX_uT(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getMagY_uT(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getMagZ_uT(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getTemperature_C(),6);\n  Serial.print("\\n");\n  delay(100);\n}\n')),Object(a.b)("h2",{id:"bmp388"},"BMP388"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),"")),Object(a.b)("h2",{id:"lora-rfm95w"},"LoRa RFM95W"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),"")),Object(a.b)("h2",{id:"microsd-adapter"},"MicroSD Adapter"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),'#include <Arduino.h>\n#include <SPI.h>\n#include <SD.h>\n\nvoid initializeCard(void);\nvoid eof(void);\nvoid flushBuffer(void);\nvoid readByte(void);\n\nFile fd;\nconst uint8_t BUFFER_SIZE = 20;\nchar fileName[] = "demoFile.txt"; // SD library only supports up to 8.3 names\nchar buff[BUFFER_SIZE+2] = "";  // Added two to allow a 2 char peek for EOF state\nuint8_t indexa = 0;\n\n\n\nconst uint8_t chipSelect = 27;\nconst uint8_t cardDetect = 28;\n\nenum states: uint8_t { NORMAL, E, EO };\nuint8_t state = NORMAL;\n\nbool alreadyBegan = false;  // SD.begin() misbehaves if not first call\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Standard Arduino setup function\n////////////////////////////////////////////////////////////////////////////////\nvoid setup()\n{\n  Serial.begin(57600);\n  while (!Serial);  // Wait for serial port to connect (ATmega32U4 type PCBAs)\n\n  // Note: To satisfy the AVR SPI gods the SD library takes care of setting\n  // SS_PIN as an output. We don\'t need to.\n  pinMode(cardDetect, INPUT);\n\n  initializeCard();\n}\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Arduino calls this function over and over again when running\n////////////////////////////////////////////////////////////////////////////////\nvoid loop()\n{\n  // Make sure the card is still present\n  if (!digitalRead(cardDetect))\n  {\n    initializeCard();\n  }\n\n  if (Serial.available() > 0)\n  {\n    readByte();\n    \n    if (indexa == BUFFER_SIZE)\n    {\n      flushBuffer();  // Write full buffer to \xb5SD card\n    }\n  }\n}\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Do everything from detecting card through opening the demo file\n////////////////////////////////////////////////////////////////////////////////\nvoid initializeCard(void)\n{\n  Serial.print(F("Initializing SD card..."));\n  \n  // Is there even a card?\n  if (!digitalRead(cardDetect))\n  {\n    Serial.println(F("No card detected. Waiting for card."));\n    while (!digitalRead(cardDetect));\n    delay(250); // \'Debounce insertion\'\n  }\n  \n  // Card seems to exist.  begin() returns failure\n  // even if it worked if it\'s not the first call.\n  if (!SD.begin(chipSelect) && !alreadyBegan)  // begin uses half-speed...\n  {\n    Serial.println(F("Initialization failed!"));\n    initializeCard(); // Possible infinite retry loop is as valid as anything\n  }\n  else\n  {\n    alreadyBegan = true;\n  }\n  Serial.println(F("Initialization done."));\n\n  Serial.print(fileName);\n  if (SD.exists(fileName))\n  {\n    Serial.println(F(" exists."));\n  }\n  else\n  {\n    Serial.println(F(" doesn\'t exist. Creating."));\n  }\n  \n  Serial.print("Opening file: ");\n  Serial.println(fileName);\n\n  Serial.println(F("Enter text to be written to file. \'EOF\' will terminate writing."));\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n// This function is called after the EOF command is received. It writes the\n// remaining unwritten data to the \xb5SD card, and prints out the full contents\n// of the log file.\n////////////////////////////////////////////////////////////////////////////////\nvoid eof(void)\n{\n  indexa -= 3; // Remove EOF from the end\n  flushBuffer();\n  \n  // Re-open the file for reading:\n  fd = SD.open(fileName);\n  if (fd)\n  {\n    Serial.println("");\n    Serial.print(fileName);\n    Serial.println(":");\n\n    while (fd.available())\n    {\n      Serial.write(fd.read());\n    }\n  }\n  else\n  {\n    Serial.print("Error opening ");\n    Serial.println(fileName);\n  }\n  fd.close();\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Write the buffer to the log file. If we are possibly in the EOF state, verify\n// that to make sure the command isn\'t written to the file.\n////////////////////////////////////////////////////////////////////////////////\nvoid flushBuffer(void)\n{\n  fd = SD.open(fileName, FILE_WRITE);\n  if (fd) {\n    switch (state)  // If a flush occurs in the \'E\' or the \'EO\' state, read more to detect EOF\n    {\n    case NORMAL:\n      break;\n    case E:\n      readByte();\n      readByte();\n      break;\n    case EO:\n      readByte();\n      break;\n    }\n    fd.write(buff, indexa);\n    fd.flush();\n    indexa = 0;\n    fd.close();\n  }\n}\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Reads a byte from the serial connection. This also maintains the state to\n// capture the EOF command.\n////////////////////////////////////////////////////////////////////////////////\nvoid readByte(void)\n{\n  byte byteRead = Serial.read();\n  Serial.write(byteRead); // Echo\n  buff[indexa++] = byteRead;\n  \n  // Must be \'EOF\' to not get confused with words such as \'takeoff\' or \'writeoff\'\n  if (byteRead == \'E\' && state == NORMAL)\n  {\n    state = E;\n  }\n  else if (byteRead == \'O\' && state == E)\n  {\n    state = EO;\n  }\n  else if (byteRead == \'F\' && state == EO)\n  {\n    eof();\n    state = NORMAL;\n  }\n}\n')),Object(a.b)("h2",{id:"mtk3339"},"MTK3339"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),'#include <Arduino.h>\n#include <Adafruit_GPS.h>\n#include <SoftwareSerial.h>\n\n// You can change the pin numbers to match your wiring:\nSoftwareSerial mySerial(0, 1);\n\n#define PMTK_SET_NMEA_UPDATE_1HZ  "$PMTK220,1000*1F"\n#define PMTK_SET_NMEA_UPDATE_5HZ  "$PMTK220,200*2C"\n#define PMTK_SET_NMEA_UPDATE_10HZ "$PMTK220,100*2F"\n\n// turn on only the second sentence (GPRMC)\n#define PMTK_SET_NMEA_OUTPUT_RMCONLY "$PMTK314,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0*29"\n// turn on GPRMC and GGA\n#define PMTK_SET_NMEA_OUTPUT_RMCGGA "$PMTK314,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0*28"\n// turn on ALL THE DATA\n#define PMTK_SET_NMEA_OUTPUT_ALLDATA "$PMTK314,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0*28"\n// turn off output\n#define PMTK_SET_NMEA_OUTPUT_OFF "$PMTK314,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0*28"\n\n#define PMTK_Q_RELEASE "$PMTK605*31"\n\nvoid setup() {\n  while (!Serial); // wait for Serial to be ready\n\n  Serial.begin(57600); // this baud rate doesn\'t actually matter!\n  mySerial.begin(9600);\n  delay(2000);\n  Serial.println("Get version!");\n  mySerial.println(PMTK_Q_RELEASE);\n\n  // you can send various commands to get it started\n  //mySerial.println(PMTK_SET_NMEA_OUTPUT_RMCGGA);\n  mySerial.println(PMTK_SET_NMEA_OUTPUT_ALLDATA);\n\n  mySerial.println(PMTK_SET_NMEA_UPDATE_1HZ);\n }\n\n\nvoid loop() {\n  if (Serial.available()) {\n   char c = Serial.read();\n   Serial.write(c);\n   mySerial.write(c);\n  }\n  if (mySerial.available()) {\n    char c = mySerial.read();\n    Serial.write(c);\n  }\n}\n')))}c.isMDXComponent=!0},109:function(n,e,t){"use strict";t.d(e,"a",(function(){return u})),t.d(e,"b",(function(){return S}));var i=t(0),r=t.n(i);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function l(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,i)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?l(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,i,r=function(n,e){if(null==n)return{};var t,i,r={},a=Object.keys(n);for(i=0;i<a.length;i++)t=a[i],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(i=0;i<a.length;i++)t=a[i],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var d=r.a.createContext({}),c=function(n){var e=r.a.useContext(d),t=e;return n&&(t="function"==typeof n?n(e):o(o({},e),n)),t},u=function(n){var e=c(n.components);return r.a.createElement(d.Provider,{value:e},n.children)},p={inlineCode:"code",wrapper:function(n){var e=n.children;return r.a.createElement(r.a.Fragment,{},e)}},f=r.a.forwardRef((function(n,e){var t=n.components,i=n.mdxType,a=n.originalType,l=n.parentName,d=s(n,["components","mdxType","originalType","parentName"]),u=c(t),f=i,S=u["".concat(l,".").concat(f)]||u[f]||p[f]||a;return t?r.a.createElement(S,o(o({ref:e},d),{},{components:t})):r.a.createElement(S,o({ref:e},d))}));function S(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var a=t.length,l=new Array(a);l[0]=f;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=n,o.mdxType="string"==typeof n?n:i,l[1]=o;for(var d=2;d<a;d++)l[d]=t[d];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,t)}f.displayName="MDXCreateElement"}}]);