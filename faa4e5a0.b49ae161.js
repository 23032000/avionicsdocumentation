(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{102:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return l})),t.d(n,"metadata",(function(){return o})),t.d(n,"toc",(function(){return s})),t.d(n,"default",(function(){return c}));var i=t(3),r=t(7),a=(t(0),t(107)),l={id:"testes",title:"C\xf3digos de Teste",sidebar_label:"Testes"},o={unversionedId:"aurorav2/software/testes",id:"aurorav2/software/testes",isDocsHomePage:!1,title:"C\xf3digos de Teste",description:"Os trechos de c\xf3digo abaixo servem para testar os m\xf3dulos presentes no EPS e CDHS. Eles foram utilizados durante a valida\xe7\xe3o das placas-prot\xf3tipo e servem para identificar o funcionamento correto dos sensores.",source:"@site/docs/aurorav2/software/testes.md",slug:"/aurorav2/software/testes",permalink:"/avionicsdocumentation/docs/aurorav2/software/testes",editUrl:"https://github.com/gabrielaleks/avionicsdocumentation/edit/master/my-website/docs/aurorav2/software/testes.md",version:"current",sidebar_label:"Testes",sidebar:"docs",previous:{title:"Reuni\xe3o 20/01/21",permalink:"/avionicsdocumentation/docs/reuniao/2001r"},next:{title:"Design Rule Check (DRC)",permalink:"/avionicsdocumentation/docs/aurorav2/hardware/altium/drc"}},s=[{value:"I2C Scanner",id:"i2c-scanner",children:[]},{value:"INA219",id:"ina219",children:[]},{value:"BMP280",id:"bmp280",children:[]},{value:"MPU9250",id:"mpu9250",children:[]},{value:"BMP388",id:"bmp388",children:[]},{value:"LoRa RFM95W",id:"lora-rfm95w",children:[]},{value:"MicroSD Adapter",id:"microsd-adapter",children:[]},{value:"MTK3339",id:"mtk3339",children:[]}],d={toc:s};function c(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(a.b)("wrapper",Object(i.a)({},d,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Os trechos de c\xf3digo abaixo servem para testar os m\xf3dulos presentes no EPS e CDHS. Eles foram utilizados durante a valida\xe7\xe3o das placas-prot\xf3tipo e servem para identificar o funcionamento correto dos sensores."),Object(a.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(a.b)("div",Object(i.a)({parentName:"div"},{className:"admonition-heading"}),Object(a.b)("h5",{parentName:"div"},Object(a.b)("span",Object(i.a)({parentName:"h5"},{className:"admonition-icon"}),Object(a.b)("svg",Object(i.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(a.b)("path",Object(i.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})))),"Observa\xe7\xe3o")),Object(a.b)("div",Object(i.a)({parentName:"div"},{className:"admonition-content"}),Object(a.b)("p",{parentName:"div"},"Cada trecho abaixo inicia o monitor serial numa taxa diferente. Lembre-se de fazer o ajuste necess\xe1rio em platformio.ini"))),Object(a.b)("h2",{id:"i2c-scanner"},"I2C Scanner"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),'#include <Arduino.h>\n#include <Wire.h>\n \nvoid setup()\n{\n  Wire.begin();\n \n  Serial.begin(9600);\n  while (!Serial);             // Leonardo: wait for serial monitor\n  Serial.println("\\nI2C Scanner");\n}\n \n \nvoid loop()\n{\n  byte error, address;\n  int nDevices;\n \n  Serial.println("Scanning...");\n \n  nDevices = 0;\n  for(address = 1; address < 127; address++ )\n  {\n    // The i2c_scanner uses the return value of\n    // the Write.endTransmisstion to see if\n    // a device did acknowledge to the address.\n    Wire.beginTransmission(address);\n    error = Wire.endTransmission();\n \n    if (error == 0)\n    {\n      Serial.print("I2C device found at address 0x");\n      if (address<16)\n        Serial.print("0");\n      Serial.print(address,HEX);\n      Serial.println("  !");\n \n      nDevices++;\n    }\n    else if (error==4)\n    {\n      Serial.print("Unknown error at address 0x");\n      if (address<16)\n        Serial.print("0");\n      Serial.println(address,HEX);\n    }    \n  }\n  if (nDevices == 0)\n    Serial.println("No I2C devices found\\n");\n  else\n    Serial.println("done\\n");\n \n  delay(5000);           // wait 5 seconds for next scan\n}\n')),Object(a.b)("h2",{id:"ina219"},"INA219"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),'#include <Arduino.h>\n#include <Adafruit_Sensor.h>\n#include <Wire.h>\n#include <Adafruit_INA219.h>\n\nAdafruit_INA219 ina219;\n\nvoid setup(void) \n{\n  Serial.begin(115200);\n  while (!Serial) {\n      // will pause Zero, Leonardo, etc until serial console opens\n      delay(1);\n  }\n\n  uint32_t currentFrequency;\n    \n  Serial.println("Hello!");\n  \n  // Initialize the INA219.\n  // By default the initialization will use the largest range (32V, 2A).  However\n  // you can call a setCalibration function to change this range (see comments).\n  if (! ina219.begin()) {\n    Serial.println("Failed to find INA219 chip");\n    while (1) { delay(10); }\n  }\n  // To use a slightly lower 32V, 1A range (higher precision on amps):\n  //ina219.setCalibration_32V_1A();\n  // Or to use a lower 16V, 400mA range (higher precision on volts and amps):\n  //ina219.setCalibration_16V_400mA();\n\n  Serial.println("Measuring voltage and current with INA219 ...");\n}\n\nvoid loop(void) \n{\n  float shuntvoltage = 0;\n  float busvoltage = 0;\n  float current_mA = 0;\n  float loadvoltage = 0;\n  float power_mW = 0;\n\n  shuntvoltage = ina219.getShuntVoltage_mV();\n  busvoltage = ina219.getBusVoltage_V();\n  current_mA = ina219.getCurrent_mA();\n  power_mW = ina219.getPower_mW();\n  loadvoltage = busvoltage + (shuntvoltage / 1000);\n  \n  Serial.print("Bus Voltage:   "); Serial.print(busvoltage); Serial.println(" V");\n  Serial.print("Shunt Voltage: "); Serial.print(shuntvoltage); Serial.println(" mV");\n  Serial.print("Load Voltage:  "); Serial.print(loadvoltage); Serial.println(" V");\n  Serial.print("Current:       "); Serial.print(current_mA); Serial.println(" mA");\n  Serial.print("Power:         "); Serial.print(power_mW); Serial.println(" mW");\n  Serial.println("");\n\n  delay(2000);\n}\n')),Object(a.b)("h2",{id:"bmp280"},"BMP280"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),'#include <Wire.h>\n#include <SPI.h>\n#include <Adafruit_BMP280.h>\n\nAdafruit_BMP280 bmp; // use I2C interface\nAdafruit_Sensor *bmp_temp = bmp.getTemperatureSensor();\nAdafruit_Sensor *bmp_pressure = bmp.getPressureSensor();\n\nvoid setup() {\n  Serial.begin(9600);\n  Serial.println(F("BMP280 Sensor event test"));\n\n  if (!bmp.begin()) {\n    Serial.println(F("Could not find a valid BMP280 sensor, check wiring!"));\n    while (1) delay(10);\n  }\n\n  /* Default settings from datasheet. */\n  bmp.setSampling(Adafruit_BMP280::MODE_NORMAL,     /* Operating Mode. */\n                  Adafruit_BMP280::SAMPLING_X2,     /* Temp. oversampling */\n                  Adafruit_BMP280::SAMPLING_X16,    /* Pressure oversampling */\n                  Adafruit_BMP280::FILTER_X16,      /* Filtering. */\n                  Adafruit_BMP280::STANDBY_MS_500); /* Standby time. */\n\n  bmp_temp->printSensorDetails();\n}\n\nvoid loop() {\n  sensors_event_t temp_event, pressure_event;\n  bmp_temp->getEvent(&temp_event);\n  bmp_pressure->getEvent(&pressure_event);\n  \n  Serial.print(F("Temperature = "));\n  Serial.print(temp_event.temperature);\n  Serial.println(" *C");\n\n  Serial.print(F("Pressure = "));\n  Serial.print(pressure_event.pressure);\n  Serial.println(" hPa");\n\n  Serial.println();\n  delay(2000);\n}\n')),Object(a.b)("h2",{id:"mpu9250"},"MPU9250"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),'#include <Arduino.h>\n#include "MPU9250.h"\n\n// an MPU9250 object with the MPU-9250 sensor on I2C bus 0 with address 0x68\nMPU9250 IMU(Wire,0x68);\nint status;\n\nvoid setup() {\n  // serial to display data\n  Serial.begin(115200);\n  while(!Serial) {}\n\n  // start communication with IMU \n  status = IMU.begin();\n  if (status < 0) {\n    Serial.println("IMU initialization unsuccessful");\n    Serial.println("Check IMU wiring or try cycling power");\n    Serial.print("Status: ");\n    Serial.println(status);\n    while(1) {}\n  }\n\n}\n\nvoid loop() {\n  // read the sensor\n  IMU.readSensor();\n  // display the data\n  Serial.print(IMU.getAccelX_mss(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getAccelY_mss(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getAccelZ_mss(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getGyroX_rads(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getGyroY_rads(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getGyroZ_rads(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getMagX_uT(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getMagY_uT(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getMagZ_uT(),6);\n  Serial.print("\\t");\n  Serial.print(IMU.getTemperature_C(),6);\n  Serial.print("\\n");\n  delay(100);\n}\n')),Object(a.b)("h2",{id:"bmp388"},"BMP388"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),'#include <Arduino.h>\n#include <Wire.h>\n#include <SPI.h>\n#include <Adafruit_Sensor.h>\n#include "Adafruit_BMP3XX.h"\n \n#define BMP_SCK 13\n#define BMP_MISO 12\n#define BMP_MOSI 11\n#define BMP_CS 10\n \n#define SEALEVELPRESSURE_HPA (1012)\n \nAdafruit_BMP3XX bmp;\n \nvoid setup() {\n  Serial.begin(115200);\n  while (!Serial);\n  Serial.println("Adafruit BMP388 / BMP390 test");\n \n  if (!bmp.begin_I2C()) {   // hardware I2C mode, can pass in address & alt Wire\n  //if (! bmp.begin_SPI(BMP_CS)) {  // hardware SPI mode  \n  //if (! bmp.begin_SPI(BMP_CS, BMP_SCK, BMP_MISO, BMP_MOSI)) {  // software SPI mode\n    Serial.println("Could not find a valid BMP3 sensor, check wiring!");\n    while (1);\n  }\n \n  // Set up oversampling and filter initialization\n  bmp.setTemperatureOversampling(BMP3_OVERSAMPLING_8X);\n  bmp.setPressureOversampling(BMP3_OVERSAMPLING_4X);\n  bmp.setIIRFilterCoeff(BMP3_IIR_FILTER_COEFF_3);\n  bmp.setOutputDataRate(BMP3_ODR_50_HZ);\n}\n \nvoid loop() {\n  if (! bmp.performReading()) {\n    Serial.println("Failed to perform reading :(");\n    return;\n  }\n  Serial.print("Temperature = ");\n  Serial.print(bmp.temperature);\n  Serial.println(" *C");\n \n  Serial.print("Pressure = ");\n  Serial.print(bmp.pressure / 100.0);\n  Serial.println(" hPa");\n \n  Serial.print("Approx. Altitude = ");\n  Serial.print(bmp.readAltitude(SEALEVELPRESSURE_HPA));\n  Serial.println(" m");\n \n  Serial.println();\n  delay(2000);\n}\n')),Object(a.b)("h2",{id:"lora-rfm95w"},"LoRa RFM95W"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),"")),Object(a.b)("h2",{id:"microsd-adapter"},"MicroSD Adapter"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),'#include <Arduino.h>\n#include <SPI.h>\n#include <SD.h>\n\nvoid initializeCard(void);\nvoid eof(void);\nvoid flushBuffer(void);\nvoid readByte(void);\n\nFile fd;\nconst uint8_t BUFFER_SIZE = 20;\nchar fileName[] = "demoFile.txt"; // SD library only supports up to 8.3 names\nchar buff[BUFFER_SIZE+2] = "";  // Added two to allow a 2 char peek for EOF state\nuint8_t indexa = 0;\n\n\n\nconst uint8_t chipSelect = 27;\nconst uint8_t cardDetect = 28;\n\nenum states: uint8_t { NORMAL, E, EO };\nuint8_t state = NORMAL;\n\nbool alreadyBegan = false;  // SD.begin() misbehaves if not first call\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Standard Arduino setup function\n////////////////////////////////////////////////////////////////////////////////\nvoid setup()\n{\n  Serial.begin(57600);\n  while (!Serial);  // Wait for serial port to connect (ATmega32U4 type PCBAs)\n\n  // Note: To satisfy the AVR SPI gods the SD library takes care of setting\n  // SS_PIN as an output. We don\'t need to.\n  pinMode(cardDetect, INPUT);\n\n  initializeCard();\n}\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Arduino calls this function over and over again when running\n////////////////////////////////////////////////////////////////////////////////\nvoid loop()\n{\n  // Make sure the card is still present\n  if (!digitalRead(cardDetect))\n  {\n    initializeCard();\n  }\n\n  if (Serial.available() > 0)\n  {\n    readByte();\n    \n    if (indexa == BUFFER_SIZE)\n    {\n      flushBuffer();  // Write full buffer to \xb5SD card\n    }\n  }\n}\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Do everything from detecting card through opening the demo file\n////////////////////////////////////////////////////////////////////////////////\nvoid initializeCard(void)\n{\n  Serial.print(F("Initializing SD card..."));\n  \n  // Is there even a card?\n  if (!digitalRead(cardDetect))\n  {\n    Serial.println(F("No card detected. Waiting for card."));\n    while (!digitalRead(cardDetect));\n    delay(250); // \'Debounce insertion\'\n  }\n  \n  // Card seems to exist.  begin() returns failure\n  // even if it worked if it\'s not the first call.\n  if (!SD.begin(chipSelect) && !alreadyBegan)  // begin uses half-speed...\n  {\n    Serial.println(F("Initialization failed!"));\n    initializeCard(); // Possible infinite retry loop is as valid as anything\n  }\n  else\n  {\n    alreadyBegan = true;\n  }\n  Serial.println(F("Initialization done."));\n\n  Serial.print(fileName);\n  if (SD.exists(fileName))\n  {\n    Serial.println(F(" exists."));\n  }\n  else\n  {\n    Serial.println(F(" doesn\'t exist. Creating."));\n  }\n  \n  Serial.print("Opening file: ");\n  Serial.println(fileName);\n\n  Serial.println(F("Enter text to be written to file. \'EOF\' will terminate writing."));\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n// This function is called after the EOF command is received. It writes the\n// remaining unwritten data to the \xb5SD card, and prints out the full contents\n// of the log file.\n////////////////////////////////////////////////////////////////////////////////\nvoid eof(void)\n{\n  indexa -= 3; // Remove EOF from the end\n  flushBuffer();\n  \n  // Re-open the file for reading:\n  fd = SD.open(fileName);\n  if (fd)\n  {\n    Serial.println("");\n    Serial.print(fileName);\n    Serial.println(":");\n\n    while (fd.available())\n    {\n      Serial.write(fd.read());\n    }\n  }\n  else\n  {\n    Serial.print("Error opening ");\n    Serial.println(fileName);\n  }\n  fd.close();\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Write the buffer to the log file. If we are possibly in the EOF state, verify\n// that to make sure the command isn\'t written to the file.\n////////////////////////////////////////////////////////////////////////////////\nvoid flushBuffer(void)\n{\n  fd = SD.open(fileName, FILE_WRITE);\n  if (fd) {\n    switch (state)  // If a flush occurs in the \'E\' or the \'EO\' state, read more to detect EOF\n    {\n    case NORMAL:\n      break;\n    case E:\n      readByte();\n      readByte();\n      break;\n    case EO:\n      readByte();\n      break;\n    }\n    fd.write(buff, indexa);\n    fd.flush();\n    indexa = 0;\n    fd.close();\n  }\n}\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Reads a byte from the serial connection. This also maintains the state to\n// capture the EOF command.\n////////////////////////////////////////////////////////////////////////////////\nvoid readByte(void)\n{\n  byte byteRead = Serial.read();\n  Serial.write(byteRead); // Echo\n  buff[indexa++] = byteRead;\n  \n  // Must be \'EOF\' to not get confused with words such as \'takeoff\' or \'writeoff\'\n  if (byteRead == \'E\' && state == NORMAL)\n  {\n    state = E;\n  }\n  else if (byteRead == \'O\' && state == E)\n  {\n    state = EO;\n  }\n  else if (byteRead == \'F\' && state == EO)\n  {\n    eof();\n    state = NORMAL;\n  }\n}\n')),Object(a.b)("h2",{id:"mtk3339"},"MTK3339"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-cpp"}),'#include <Arduino.h>\n#include <Adafruit_GPS.h>\n#include <SoftwareSerial.h>\n\n// You can change the pin numbers to match your wiring:\nSoftwareSerial mySerial(0, 1);\n\n#define PMTK_SET_NMEA_UPDATE_1HZ  "$PMTK220,1000*1F"\n#define PMTK_SET_NMEA_UPDATE_5HZ  "$PMTK220,200*2C"\n#define PMTK_SET_NMEA_UPDATE_10HZ "$PMTK220,100*2F"\n\n// turn on only the second sentence (GPRMC)\n#define PMTK_SET_NMEA_OUTPUT_RMCONLY "$PMTK314,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0*29"\n// turn on GPRMC and GGA\n#define PMTK_SET_NMEA_OUTPUT_RMCGGA "$PMTK314,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0*28"\n// turn on ALL THE DATA\n#define PMTK_SET_NMEA_OUTPUT_ALLDATA "$PMTK314,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0*28"\n// turn off output\n#define PMTK_SET_NMEA_OUTPUT_OFF "$PMTK314,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0*28"\n\n#define PMTK_Q_RELEASE "$PMTK605*31"\n\nvoid setup() {\n  while (!Serial); // wait for Serial to be ready\n\n  Serial.begin(57600); // this baud rate doesn\'t actually matter!\n  mySerial.begin(9600);\n  delay(2000);\n  Serial.println("Get version!");\n  mySerial.println(PMTK_Q_RELEASE);\n\n  // you can send various commands to get it started\n  //mySerial.println(PMTK_SET_NMEA_OUTPUT_RMCGGA);\n  mySerial.println(PMTK_SET_NMEA_OUTPUT_ALLDATA);\n\n  mySerial.println(PMTK_SET_NMEA_UPDATE_1HZ);\n }\n\n\nvoid loop() {\n  if (Serial.available()) {\n   char c = Serial.read();\n   Serial.write(c);\n   mySerial.write(c);\n  }\n  if (mySerial.available()) {\n    char c = mySerial.read();\n    Serial.write(c);\n  }\n}\n')))}c.isMDXComponent=!0},107:function(e,n,t){"use strict";t.d(n,"a",(function(){return p})),t.d(n,"b",(function(){return m}));var i=t(0),r=t.n(i);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function l(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?l(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):l(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var d=r.a.createContext({}),c=function(e){var n=r.a.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=c(e.components);return r.a.createElement(d.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.a.createElement(r.a.Fragment,{},n)}},f=r.a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(t),f=i,m=p["".concat(l,".").concat(f)]||p[f]||u[f]||a;return t?r.a.createElement(m,o(o({ref:n},d),{},{components:t})):r.a.createElement(m,o({ref:n},d))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,l=new Array(a);l[0]=f;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var d=2;d<a;d++)l[d]=t[d];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,t)}f.displayName="MDXCreateElement"}}]);